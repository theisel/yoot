#!/usr/bin/env node
import fs from 'fs/promises';
import path from 'path';
import fg from 'fast-glob';

const ROOT_DIR = process.cwd();
const DOCS_DIR = path.join(ROOT_DIR, 'docs');
const OUTPUT_FILE = path.join(DOCS_DIR, 'api', 'README.md');

// Extract <tr><td>...</td></tr> blocks from the <table>
async function extractPackagesFromFile(file) {
  const content = await fs.readFile(file, 'utf-8');
  const match = content.match(/<tbody>([\s\S]*?)<\/tbody>/);

  if (!match) return [];

  const fileDir = path.dirname(file);

  const rows = match[1].match(/<tr>[\s\S]*?<\/tr>/g)?.map((row) => {
    return row.replace(/(\[[^\]]+\])\(\.\/([^)]+)\)/g, (_, linkText, mdFile) => {
      const absoluteMdPath = path.resolve(fileDir, mdFile);
      const relativeToOutput = path.relative(path.dirname(OUTPUT_FILE), absoluteMdPath);
      const posixPath = relativeToOutput.split(path.sep).join(path.posix.sep);
      return `${linkText}(${posixPath})`;
    });
  });

  return rows ?? [];
}

async function extractPackagesFromFiles(files) {
  const packages = [];

  for (const file of files) {
    const rows = await extractPackagesFromFile(file);
    packages.push(...rows);
  }

  const getPackageName = (row) => {
    const [, name] = row.match(/\[@yoot\/([^\]]+)\]/) ?? [, ''];
    return name;
  };
  // Sort packages to ensure @yoot/yoot is always first,
  // followed by other packages in alphabetical order
  return packages.sort((a, b) => {
    const nameA = getPackageName(a);
    const nameB = getPackageName(b);

    if (nameA === 'yoot') return -1;
    if (nameB === 'yoot') return 1;
    return nameA.localeCompare(nameB);
  });
}

async function updateBreadcrumbs(file) {
  const content = await fs.readFile(file, 'utf-8');

  // Skip `/index.md` files
  if (file.endsWith('/index.md')) return;

  const [lastBreadcrumb] = content.match(/&gt;\s+\[([^\]]+)]\([^)]+\)/g).reverse();

  const updated = content
    .replace(/\[Home\]\([^)]+\)/, `[Home](/docs/README.md) &gt; [API Reference](/docs/api/README.md)`)
    .replace(
      lastBreadcrumb,
      lastBreadcrumb.replace(/\[([^\]]+)\](.*)/, '<span style="opacity:0.7;font-style:italic">$1</span>'),
    );

  await fs.writeFile(file, updated);
}

// Build the final README.md content
function generateCombinedMarkdown(rows) {
  return `<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](/docs/README.md)

## API Reference

## Packages

<table><thead><tr><th>

Package

</th><th>

Description

</th></tr></thead>
<tbody>
${rows.join('\n')}
</tbody></table>
`;
}

// Main
async function main() {
  const [indexFiles, allFiles] = await Promise.all([fg('docs/**/index.md'), fg('docs/packages/**/*.md')]);

  const packages = await extractPackagesFromFiles(indexFiles);
  await Promise.all(allFiles.map(updateBreadcrumbs));

  // Output the combined API index
  await fs.mkdir(path.dirname(OUTPUT_FILE), {recursive: true});
  const output = generateCombinedMarkdown(packages);
  await fs.writeFile(OUTPUT_FILE, output);
  console.log(`‚úÖ Merged ${packages.length} packages into ${OUTPUT_FILE}`);

  // Delete the individual index.md files
  await Promise.all(indexFiles.map((file) => fs.unlink(file)));
  console.log(`üóëÔ∏è  Deleted ${indexFiles.length} index.md files`);
}

main().catch((err) => {
  console.error('‚ùå Error during documentation merge:', err);
  process.exit(1);
});
